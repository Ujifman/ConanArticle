# ConanArticle

Статья про наше использование Conan для Habr.

**Title**: Как мы навели порядок в C++/Qt проекте с помощью Conan

## Пару слов о проекте

### Максимально коротко

Мы создаем систему по обмену аэронавигационной информацией между филиалами организации, которая разрабатывает и поддерживает структуру воздушного пространства в РФ. Система распределенная: в каждом филиале установлен автономный комплекс. Комплексы из разных филиалов обмениваются между собой изменениями аэронавигационной информации.

### Теперь подробнее

Комплекс представляет из себя несколько железных серверов в кластере, на котором работает набор backend сервисов (серверная система CentOS), и несколько рабочих мест операторов (ПК на Windows). На рабочих местах установлено Desktop приложение на C++/Qt, которое взаимодйствует с backend'ом. Система разрабатывается уже много лет, поэтому мы имеем неплохой багаж legacy.

Desktop приложение модульное, главный UI подгружает из динамических библиотек интерфейсы для выполнения различных задач. Каждый отдельный модуль имеет свою либу (читай `dll`/`so`). Кроме того модули используют общий код доступа к БД, доступа к backend сервисам, реализации логгирования и т.д. Общий код также выдлен в отдельные либы статические и динамические.

Некоторые backend сервисы также написаны на C++/Qt и используют библиотеки доступа к БД, те же самые, которые использует Desktop приложение.

Итого имеем на C++/Qt:

- 26 динамических библиотек (15 GUI модулей и 11 модулей с бизнес логикой)
- 11 статических библиотек
- 6 сторонних open source библиотек (докрученных для наших нужд)
- 2 Desktop приложения
- 2 backend сервиса

Все вышеперечисленное местами друг друга использует.

В итоге на упрощенном примере получается следующая карта зависимостей:

```mermaid
graph TD
app_client(ClientApp)
lib_users(UsersGuiModule)
lib_data(DataGuiModule)
gui_prim(GuiPrimitives)
lib_db(DbInterface)
templates(Templates)
app_backend(SomeBackendApp)

app_client --> lib_users & lib_data
lib_users & lib_data --> gui_prim
lib_users & lib_data --> lib_db
lib_users & gui_prim & lib_db--> templates
app_backend ---> lib_db & templates
```

Теперь эту схему масштабируем до нашего количества либ и возникает вопрос: как все это согласованно содержать и допиливать?

## Проблемы, которые надо решить

- Централизованное управление всем деревом зависимостей, типовые пайплайны сборки
- Независимая разработка модулей: для разработчика удобно запускать определенный GUI модуль отдельно от всего приложения - изолированно, для этого ему нужны актуальные версии всех зависимостей
- Неплохо бы разделять `dev` и `production` пространства и сделать удобным доступ для тестировщиков к свежим фичам, при этом случайно не выкатить в прод сырой код.
- Еще не забываем про Git Flow и ветвление: 1 фича - отдельная ветка; все мы знаем, что в одной ветке пилить плохо. Это все прекрасно работает, пока репозиторий один. Когда итоговое Desktop приложение включает в себя кучу репозиториев, а некоторые из них зависят от других репозиториев, мы приходим к весьма сложной и запутанной структуре.
- Можно еще подумать о сокращении времени CI/CD на build и билдить либы изолированно друг от друга и хранить
- 2 платформы Linux/Windows и минимум 2 версии Qt (переходные периоды в любом случае присутствуют)
- Иногда баг сквозит через несколько либ, и надо иметь возможность дебажить сквозь несколько зависимостей
- В основном мы используем QMake, но некоторые сторонние либы используют CMake, надо уметь с этим жить

## У самурая нет цели, есть только путь

Много много лет назад в одной отдаленной галактике... мы поняли, что так дальше жить нельзя, надо искать решение.

### Вариант 1, монорепозиторий

Когда проект стартовал, он весь состоял из Desktop приложения и БД, backend сервисов тогда еще не было. Это было лет 8 назад, и Desktop приложение было в монорепозитории. В корне лежал один большой Qt `.pro` файл, который через `subdirs` включал все GUI модули и внутренние либы. Все они плоско лежали в репозитории в подпапках, собирались по порядку и подключались уже бинарями.

Плюсы:

- Все в одном месте, просто фиксить баг, который сквозит через библиотеки или делать фичу, которая сквозит через библиотеки
- Нет проблем с ветвлением

Минусы:

- Дикое время сборки
- Высокая вероятность высокой связанности (coupling)
- Все разработчики в одном репозитории
- Очень сложно взять либу в другой проект
- Сложно организовать изолированное приложение для одного GUI модуля

### Вариант 2, git submodules

Мы начали искать варианты разделения на отдельные репозитории. И на тот момент единственным вариантом выглядел `git submodules`. В итоге распилив монорепозиторий мы получили, каждую либу в отдельном репозитории. Репозиторий главного Desktop приложения подключает их как git сабмодули, и в принципе репозиторий Desktop приложения на вид не изменился. Зато появилась возможность отдельно работать с GUI модулем. И тут возникла новая сложность.

Возникла проблема с подключением либ с общим кодом (например доступа к БД), если ее вложить в каждый репозиторий GUI модуля, то когда они все собираются в репозитории главного GUI приложения получается куча дублирований одного и того же общего кода.

Поэтому было решено либы с общим кодом не подключать в GUI модули git сабмодулями. В репозиторий главного приложения уложить GUI модули и либы с общим кодом на одном уровне в корне. Тогда инклюды в GUI модулях всегда идут на шаг вверх и в папку нужного модуля с общим кодом.

Это привело к тому, что код в репозитории GUI модуля, у которого есть зависимости, несамостоятельный, и собрать его просто клонировав репозиторий не получится. Для того, чтобы запустить код модуля отдельно отприложения мы создавали отдельный репозиторий с сэмплом, и в него включали сам модуль и его зависимости. В итоге куча лишних репозиториев.

**Упрощенный пример репозитория главного приложения:**

```mermaid
graph LR
app_client(ClientApp Repo)
lib_users(UsersGuiModule Repo)
lib_data(DataGuiModule Repo)
gui_prim(GuiPrimitives Repo)
lib_db(DbInterface Repo)
templates(Templates Repo)

app_client --> lib_users & lib_data & gui_prim & lib_db & templates
```

**Упрощенный пример репозитория бэкенд приложения:**

```mermaid
graph LR
lib_db(DbInterface Repo)
templates(Templates Repo)
app_backend(SomeBackendApp Repo)

app_backend ---> lib_db & templates
```

**Упрощенный пример репозитория с сэмплом:**

```mermaid
graph LR
app_client(UsersGuiSample Repo)
lib_users(UsersGuiModule Repo)
gui_prim(GuiPrimitives Repo)
lib_db(DbInterface Repo)
templates(Templates Repo)

app_client --> lib_users & gui_prim & lib_db & templates
```

Плюсы:

- Разбиение на модули по изолированным репозиториям
- Сложно фиксить баг или делать фичу, которая сквозит через несколько либ (это проблема высокой связанности, поэтому сложности автоматически стимулируют лучше разделять, так что это необходимые сложности которые идут во благо)

Минусы:

- Постоянная возня с `git submodules update`
- Каждое изменение ветки подмодуля приводит к коммиту в репозитории, который его включает, чтобы обновить ссылку подмодуля
- Куча лишних репозиториев с сэмплами, с такими же проблемами с ветвлением
- Все такое же дикое время сборки
- И самое сладкое, полнейший дурдом с ветвлением

### Вариант 3, пакетный менеджер

И вот в один прекрасный день мой коллега (спасибо @madmax) нашел его:

![2022-05-15-14-59-43.png](README.assets/2022-05-15-14-59-43.png)

Точнее его:

![2022-05-15-15-00-18.png](README.assets/2022-05-15-15-00-18.png)

Мы потратили примерно 2 месяца на осознание, набивание шишек, построение и разрушение костылей и велосипедов. Потом пришел бизнес и сказал, что пора уже код писать.
Мы запустились на том, что получилось.
Потом еще пару лет эволюции и сейчас наша концепция выглядит вполне живой и бодрой.

### Инкапсуляция логики сборки

Вся логика сборки под разные платформы инкаспулирована в общий `conanfile.py`, который также является Conan пакетом и инклюдится в либы.

CommonConanFile инкапсулирует

- логику подмены каналов при разруливании графа зависимостей (`ConanFile.requirements`, `ConanFile.build_requirements`)
- возможные `ConanFile.settings` и `Conanfile.options`
- логику укладки исходников в пакет
- логику подкладки переиспользуемых `.pri` файлов
- логику компиляции (`ConanFile.build()`)
- логику прокатки unit тестов и сбора coverage report
- логику упаковки пакета (`ConanFile.package()`) а также информации по нему (`ConanFile.package_info()`)

Посмотреть на наш conafile можно по [ссылке](github) ==link==.

#### Диаграмма классвов CommonConanFile

- `AbstractConanFile` - базовый ConanFile, являющийся родителем для всех остальных и реализующий логику упаковки пакета и разрауливания зависимостей, то что нужно всем пакетам
- `HeaderOnlyConanFile` - ConanFile для header-only пакетов, которым не нужен build
- `QmakePriOnlyConanFile` - ConanFile для пакетов, которые подкладывают переиспользуемые `.pri` файлы, для переиспользования кода qmake pro файлов
- `BuildableConanFile` - базовая реализация компилируемого пакета
- `StaticLibConanFile` - пакет, собирающийся в статическую либу
- `DynamicLibConanFile` - пакет, собирающийся в динамическую либо
- `ApplicationConanFile` - пакет, собирающийся в приложение

```mermaid
classDiagram

class ConanFile {
    +requirements()
    +build_requirements()
    +package()
    +config_options()
    +deploy()
}

class AbstractConanFile {
    <<abstract>>
    -license | override

    -requirements_substitution()
    +requirements() | override
    +build_requirements() | override
    +package() | override
    +package_info() | override
}

class HeaderOnlyConanFile {
    +no_copy_source = True
}

class QmakePriOnlyConanFile {
    +no_copy_source = True
}

class BuildableType {
    <<enumeration>>
    shared
    static
    app
}

class BuildableConanFile {
    <<abstract>>
    +settings | override
    +options | override
    +buildable_type
    -coverage()
    +config_options() | override
    +imports() | override
    +build() | override
    +package_info() | override
}

class StaticLibConanFile {
    +buildable_type = static
}

class DynamicLibConanFile {
    +buildable_type = shared
    +deploy() | override
}

class ApplicationConanFile {
    +buildable_type = app
}

ConanFile <|-- AbstractConanFile
AbstractConanFile <|-- HeaderOnlyConanFile
AbstractConanFile <|-- QmakePriOnlyConanFile
AbstractConanFile <|-- BuildableConanFile
BuildableConanFile <|-- StaticLibConanFile
BuildableConanFile <|-- DynamicLibConanFile
BuildableConanFile <|-- ApplicationConanFile
BuildableConanFile --> BuildableType: buildable_type
```

Используемые `conanfile.settings`:

```yaml
os: Linux, Windows
compiler: gcc
build_type: Debug, Release
arch: x86, x86_64
```

Используемые `conanfile.options`:

```yaml
shared: True, False
qt_ver: 5.5.1, 5.9.8, 5.13.2, 5.15.2, None
unit_testing: True, False
with_coverage: True, False
sample: True, False
```

### Пример рецепта для библиотеки

```python
from conans import ConanFile, CMake, tools
import os


class DbInterfaceConan(ConanFile):
    name = "DbInterface"
    version = "2.58.1"
    url = "https://git.monitorsoft.ru/cpp-libs/DbInterface"
    generators = "qmake"
    python_requires = "CommonConanFile/0.8@monsoft/stable"
    python_requires_extend = "CommonConanFile.DynamicLibConanFile"
    exports_sources = "src/*", "test_unit/*", "DbInterface.pro", "DbInterface_TestUnit.pro"
    run_tests_headless = False
    unit_test_executables = [
        os.sep.join([".", "test_package", "DbPrimitives", "DbInterface_Test_DbPrimitives"]),
        os.sep.join([".", "test_package", "GmlHandler", "DbInterface_Test_GmlHandler"]),
        os.sep.join([".", "test_package", "AixmDb", "DbInterface_Test_AixmDb"]),
        os.sep.join([".", "test_package", "Integrational", "DbInterface_Test_Integrational"])
    ]

    build_requires = (
                "CommonQmakePri/[~1.0.1]@monsoft/stable",
                "ZhrGeo/[~1.1]@monsoft/stable",
                "QTester/[~1.0.1]@monsoft/stable", # for tests
                "FakeIt/2.0.2@hinrikg/stable") # for tests
    requires =  (
                "Lib/[~2.24.0]@monsoft/stable",
                "Templates/[~1.7.2]@monsoft/stable",
                "Sax/[~1.1]@monsoft/stable")
```

### Управление пространствами dev/prod

Идентификация пакета Conan выглядит так `Lib/[~2.24.0]@monsoft/stable`.

`<Имя пакета>/<Версия semver>@<user>/<channel>`

Все наши пакеты (которые используют общий рецепт `CommonConanFile`) из ветки `dev` собираются в канал `dev`, а из ветки `master` в канал `stable`.

Таким образом слияние feature ветки в `dev` приводит к выходу новой `dev` версии, при этом `stable` простарнство не затрагивается.

При релизе мы сливаем все либы из `dev` в `master` и получаем обновление `stable` версий пакетов.

Самая главная фича тут в подмене канала. Все зависимости прописаны на канал `stable`, но когда мы понимаем, что собираемся в `dev` пространстве, то при выполнении `conan install` выставляем env (`OVERRIDE_CONAN_CHANNEL`), на который реагирует наш рецепт сборки, и он подменяет все пакеты в `requires` и `build_requires` с `monsoft/stable` на `monsoft/dev`. Таким образом мы по всему дереву зависимостей получаем подмену канала.

У тестировщика есть команда для установки приложения через Conan из `dev` и `stable`. Ему не надо ничего собирать, ставить IDE, компилятор или еще что-то, чтобы добыть самый свежий бинарь.

Разработчик прислал ветку на ревью -> ветку слили в `dev` -> прошла сборка на билд сервере  -> новая версия в канале `dev` -> у тестировщика самая свежая версия.

```mermaid
graph LR
%% Conan
conan(Conan)

subgraph Conan stable channel
conan-s(stable channel)
conan-s-1.2(v1.2)
conan-s-1.3(v1.3)
end

subgraph Conan dev channel
conan-d(dev channel)
conan-d-1.2(v1.2)
conan-d-1.2.1(v1.2.1)
conan-d-1.2.3(v1.2.3)
conan-d-1.2.4(v1.2.4)
conan-d-1.3(v1.3 Alias)
end

conan --> conan-s & conan-d
conan-d --> conan-d-1.2 --> conan-d-1.2.1 --> conan-d-1.2.3 --> conan-d-1.2.4 --> conan-d-1.3
conan-s --> conan-s-1.2 -----> conan-s-1.3

%% Git
git(Git)

subgraph Git master branch
git-m(master branch)
git-m-1.2(v1.2)
git-m-1.3(v1.3)
end

subgraph Git dev branch
git-d(dev branch)
git-d-1.2(v1.2)
git-d-1.2.1(v1.2.1)
git-d-1.2.3(v1.2.3)
git-d-1.2.4(v1.2.4)
end

git --> git-d & git-m
git-d --> git-d-1.2 --> git-d-1.2.1 --> git-d-1.2.3 --> git-d-1.2.4 -- merge --> git-m-1.3
git-m --> git-m-1.2 -----> git-m-1.3
```

### Отладка сквозных багов: editable пакеты

Периодически бывает так, что реализация фичи может растянуться на несколько пакетов, или же баг какой-то внутренней зависимости всплывает в верхнем паете.

В таком случае приходится после каждого изменения в используемой библиотеке делать `conan create`, что совсем не упрощает жизнь, а в данном случае даже увеличивает время разработки.
Для этого случая придумали [Conan Editable Mode](https://docs.conan.io/en/latest/developing_packages/editable_packages.html).

Фича еще пока не супер удобная, но весьма неплохо решает проблему разработки сразу на несколько библиотек.

Краткий принцип работы:

1. Настраиваем Сonan layout файл.
1. Идем в используемую либу.
1. Открываем в QtCreator и выставляем у нее сборку в папку с либой.
1. Выполняем `conan editable add`.
1. Теперь идем в использующий ее проект и выполняем в нем `conan install`.
1. Вуаля, теперь вместо кеша Conan берет бинарник, который создает Qt.
1. Открываем оба проекта в IDE, правим код и дебажим сразу в нескольких либах.
1. После окончания работы выполняем `conan editable remove`

### Дружба с IDE

Запуск Conan возможен напрямую из IDE Qt Creator с помощью модуля External Tools в Qt Creator.

Выглядит это примерно так:

![2022-09-18-16-58-32.png](README.assets/2022-09-18-16-58-32.png)

Скрипты для интеграции через External Tools можно посмотреть ==[тут]()==.

Что делают скрипты:

- Из выбранного профиля в QtCreator берут:
    - версию qt
    - версию компилятора
    - тип сборки Release/Debug
    - пути для исходников и бинарей
- Используя вышеперечисленное формируют и выполняют команду `conan install`

### Примеры CI/CD

`.gitlab-ci.yml` у всех одинаковый и выглядит вот так:

```yml
include:
- project: 'devtools/cicdscripts'
  ref: v4.1
  file: '/full-lib-pipeline.yml'
```

CI/CD скрипты мы также храним в отдельном репозитории, что упрощает их модификацю. Но это уже совсем другая история, которая потянет на отделную статью

Пайплайн выглядит так:

![2022-09-18-17-03-10.png](README.assets/2022-09-18-17-03-10.png)

## Итоговый flow

- Цикл разработки
    - Разработчики независимо друг от друга пилят фичи в feature-ветках библиотек
    - Присылают реквесты на слияние в dev каждый по своей библиотеке
    - Тимлид проводит CodeReview и просто тыкает Merge
    - Либы собираются и попадают в dev канал
    - Тестироващик делает `conan install` из dev и ему подъезжают все свежие изменения
    - В случае багов цикл повторяется
- Цикл разработки независимо для каждого разработчика начинается заново
- Мы подходим к релизу
- Все Merge Request*ы* по feature веткам повисают, пока тестировщики заканчивают тестирование по уже влитым фичам и разработчики добивают баги
- Все допилено
- Тимлид скриптом сливает все библиотеки в master
- Запускается пересборка на GitLab CI/CD в цикле
    Зависимые библиотек не смогут собраться пока не соберуться зависимости. При этом первой джобой в CI/CD скрипте идет проверка графа Conan, поэтому на проверку, что зависимости собрались тратится 4-5 секунд.

    Пересобираться будут только те пакеты, в которых есть изменения или у которых в зависимостях есть пакеты, в которых изменилась сигнатура классов и методов(это разруливается с помощью semver)

- Часа через 4 проверяем мастер проект, к этому времени уже все зависимости собрались, он тоже должен был собраться.
- Если еще не собрался, возможно где-то есть несогласованность, тогда идем и ищем проблему по графу зависимостей

Самая главная плюшка: если мастер проект собрался, значит точно все остальные собрались с нужными версиями ОС, компилятора опциями и т.д.

## Что получилось в итоге

- Каждая библиотека, приложение лежит в своем репозитории и собирается в Conan пакет и выкладывается на Conan сервер
- В каждом репозитории идентичная структура папок и файлов, и чтобы работало необходимо во всех репозиториях ее поддерживать одинаковой
- На Conan сервере есть 2 канала `dev` и `stable`. На `dev` кладутся пакеты собранные из `dev` ветки, на `production` - из `master` ветки
- У тестировщика всегда есть доступ к самым последним фичам в `dev`, при этом легко может переключиться и получить полное приложение из `stable` канала
- Легко можно с помощью `editable` отлавливать сквозные баги
- Общий код реализации сборки, unit тестов (+ coverage), подмены канала, можно централизованно менять для всех
- Абсолютно идентичный и простой код CI/CD
- Возможность увидеть полное дерево зависимостей
- Версионирование по semver для библиотк и как следствие
- Из коробки разделение бинарей библиотек по ОС, версиям компилятора, версиям qt и еще чему угодно, что придет нам в голову
- В виде Conan пакетов можно подключать и совсем не `cpp` вещи, например файлы описывающие модель данных для mock*а* в unit естах (само описание модели данных лежит в отдельной репе с смаодельным синтаксисом)

## Заключение

Все плюсы перечислены выше, само собой у подхода есть и минусы, серебряной пули не бывает.

Минусы:

- Перед релизом (слияние в master) все слияния в dev тормозятся по всем либам, пока тестировщик не проверит уже слитый в dev функционал
- Необходимость дополнительно поскриптовать, чтобы слияние на релиз выполнять разом по всем репозиториям (но это уже победили, немного Python и GitLab API и все полуавтоматизировано)
- Дополнительные действия (Conan Editable Mode) для отладки багов, сквозящих через несколько либ
- Определенный порог входа для разработчиков (решается хорошими доками и инструкциями)
- Басфактор в поддержке всего этого великолепия (не все хотят или могут погружаться в структуру, поэтому полностью весь механизм только у одного разработчика в голове)

В конечном итоге плюсы во многом перевешивают минусы.

Желаю вам держать свои проекты в прозрачном порядке!
